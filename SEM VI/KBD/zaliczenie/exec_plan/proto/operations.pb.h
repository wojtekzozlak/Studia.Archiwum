// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: operations.proto

#ifndef PROTOBUF_operations_2eproto__INCLUDED
#define PROTOBUF_operations_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_operations_2eproto();
void protobuf_AssignDesc_operations_2eproto();
void protobuf_ShutdownFile_operations_2eproto();

class Expression;
class ScanOperation;
class ComputeOperation;
class FilterOperation;
class Aggregation;
class GroupByOperation;
class Operation;

enum Expression_Operator {
  Expression_Operator_CONSTANT = 1,
  Expression_Operator_COLUMN = 2,
  Expression_Operator_IF = 3,
  Expression_Operator_ADD = 100,
  Expression_Operator_SUBTRACT = 101,
  Expression_Operator_MULTIPLY = 102,
  Expression_Operator_FLOATING_DIVIDE = 103,
  Expression_Operator_LOG = 150,
  Expression_Operator_NEGATE = 151,
  Expression_Operator_LOWER = 200,
  Expression_Operator_GREATER = 201,
  Expression_Operator_EQUAL = 202,
  Expression_Operator_NOT_EQUAL = 203,
  Expression_Operator_NOT = 300,
  Expression_Operator_OR = 301,
  Expression_Operator_AND = 302
};
bool Expression_Operator_IsValid(int value);
const Expression_Operator Expression_Operator_Operator_MIN = Expression_Operator_CONSTANT;
const Expression_Operator Expression_Operator_Operator_MAX = Expression_Operator_AND;
const int Expression_Operator_Operator_ARRAYSIZE = Expression_Operator_Operator_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_Operator_descriptor();
inline const ::std::string& Expression_Operator_Name(Expression_Operator value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_Operator_descriptor(), value);
}
inline bool Expression_Operator_Parse(
    const ::std::string& name, Expression_Operator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Operator>(
    Expression_Operator_descriptor(), name, value);
}
enum ScanOperation_Type {
  ScanOperation_Type_INT = 1,
  ScanOperation_Type_DOUBLE = 2,
  ScanOperation_Type_BOOL = 3
};
bool ScanOperation_Type_IsValid(int value);
const ScanOperation_Type ScanOperation_Type_Type_MIN = ScanOperation_Type_INT;
const ScanOperation_Type ScanOperation_Type_Type_MAX = ScanOperation_Type_BOOL;
const int ScanOperation_Type_Type_ARRAYSIZE = ScanOperation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScanOperation_Type_descriptor();
inline const ::std::string& ScanOperation_Type_Name(ScanOperation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScanOperation_Type_descriptor(), value);
}
inline bool ScanOperation_Type_Parse(
    const ::std::string& name, ScanOperation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScanOperation_Type>(
    ScanOperation_Type_descriptor(), name, value);
}
enum Aggregation_Type {
  Aggregation_Type_SUM = 1,
  Aggregation_Type_COUNT = 2
};
bool Aggregation_Type_IsValid(int value);
const Aggregation_Type Aggregation_Type_Type_MIN = Aggregation_Type_SUM;
const Aggregation_Type Aggregation_Type_Type_MAX = Aggregation_Type_COUNT;
const int Aggregation_Type_Type_ARRAYSIZE = Aggregation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Aggregation_Type_descriptor();
inline const ::std::string& Aggregation_Type_Name(Aggregation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Aggregation_Type_descriptor(), value);
}
inline bool Aggregation_Type_Parse(
    const ::std::string& name, Aggregation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Aggregation_Type>(
    Aggregation_Type_descriptor(), name, value);
}
// ===================================================================

class Expression : public ::google::protobuf::Message {
 public:
  Expression();
  virtual ~Expression();
  
  Expression(const Expression& from);
  
  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();
  
  void Swap(Expression* other);
  
  // implements Message ----------------------------------------------
  
  Expression* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Expression_Operator Operator;
  static const Operator CONSTANT = Expression_Operator_CONSTANT;
  static const Operator COLUMN = Expression_Operator_COLUMN;
  static const Operator IF = Expression_Operator_IF;
  static const Operator ADD = Expression_Operator_ADD;
  static const Operator SUBTRACT = Expression_Operator_SUBTRACT;
  static const Operator MULTIPLY = Expression_Operator_MULTIPLY;
  static const Operator FLOATING_DIVIDE = Expression_Operator_FLOATING_DIVIDE;
  static const Operator LOG = Expression_Operator_LOG;
  static const Operator NEGATE = Expression_Operator_NEGATE;
  static const Operator LOWER = Expression_Operator_LOWER;
  static const Operator GREATER = Expression_Operator_GREATER;
  static const Operator EQUAL = Expression_Operator_EQUAL;
  static const Operator NOT_EQUAL = Expression_Operator_NOT_EQUAL;
  static const Operator NOT = Expression_Operator_NOT;
  static const Operator OR = Expression_Operator_OR;
  static const Operator AND = Expression_Operator_AND;
  static inline bool Operator_IsValid(int value) {
    return Expression_Operator_IsValid(value);
  }
  static const Operator Operator_MIN =
    Expression_Operator_Operator_MIN;
  static const Operator Operator_MAX =
    Expression_Operator_Operator_MAX;
  static const int Operator_ARRAYSIZE =
    Expression_Operator_Operator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operator_descriptor() {
    return Expression_Operator_descriptor();
  }
  static inline const ::std::string& Operator_Name(Operator value) {
    return Expression_Operator_Name(value);
  }
  static inline bool Operator_Parse(const ::std::string& name,
      Operator* value) {
    return Expression_Operator_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Expression.Operator operator = 1;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 1;
  inline ::Expression_Operator operator_() const;
  inline void set_operator_(::Expression_Operator value);
  
  // repeated .Expression children = 2;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 2;
  inline const ::Expression& children(int index) const;
  inline ::Expression* mutable_children(int index);
  inline ::Expression* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::Expression >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::Expression >*
      mutable_children();
  
  // optional int32 constant_int32 = 10;
  inline bool has_constant_int32() const;
  inline void clear_constant_int32();
  static const int kConstantInt32FieldNumber = 10;
  inline ::google::protobuf::int32 constant_int32() const;
  inline void set_constant_int32(::google::protobuf::int32 value);
  
  // optional double constant_double = 11;
  inline bool has_constant_double() const;
  inline void clear_constant_double();
  static const int kConstantDoubleFieldNumber = 11;
  inline double constant_double() const;
  inline void set_constant_double(double value);
  
  // optional bool constant_bool = 12;
  inline bool has_constant_bool() const;
  inline void clear_constant_bool();
  static const int kConstantBoolFieldNumber = 12;
  inline bool constant_bool() const;
  inline void set_constant_bool(bool value);
  
  // optional int32 column_id = 13;
  inline bool has_column_id() const;
  inline void clear_column_id();
  static const int kColumnIdFieldNumber = 13;
  inline ::google::protobuf::int32 column_id() const;
  inline void set_column_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Expression)
 private:
  inline void set_has_operator_();
  inline void clear_has_operator_();
  inline void set_has_constant_int32();
  inline void clear_has_constant_int32();
  inline void set_has_constant_double();
  inline void clear_has_constant_double();
  inline void set_has_constant_bool();
  inline void clear_has_constant_bool();
  inline void set_has_column_id();
  inline void clear_has_column_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Expression > children_;
  int operator__;
  ::google::protobuf::int32 constant_int32_;
  double constant_double_;
  bool constant_bool_;
  ::google::protobuf::int32 column_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_operations_2eproto();
  friend void protobuf_AssignDesc_operations_2eproto();
  friend void protobuf_ShutdownFile_operations_2eproto();
  
  void InitAsDefaultInstance();
  static Expression* default_instance_;
};
// -------------------------------------------------------------------

class ScanOperation : public ::google::protobuf::Message {
 public:
  ScanOperation();
  virtual ~ScanOperation();
  
  ScanOperation(const ScanOperation& from);
  
  inline ScanOperation& operator=(const ScanOperation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanOperation& default_instance();
  
  void Swap(ScanOperation* other);
  
  // implements Message ----------------------------------------------
  
  ScanOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanOperation& from);
  void MergeFrom(const ScanOperation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ScanOperation_Type Type;
  static const Type INT = ScanOperation_Type_INT;
  static const Type DOUBLE = ScanOperation_Type_DOUBLE;
  static const Type BOOL = ScanOperation_Type_BOOL;
  static inline bool Type_IsValid(int value) {
    return ScanOperation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ScanOperation_Type_Type_MIN;
  static const Type Type_MAX =
    ScanOperation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ScanOperation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ScanOperation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ScanOperation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ScanOperation_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated int32 column = 1;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::int32 column(int index) const;
  inline void set_column(int index, ::google::protobuf::int32 value);
  inline void add_column(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_column();
  
  // repeated .ScanOperation.Type type = 2;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::ScanOperation_Type type(int index) const;
  inline void set_type(int index, ::ScanOperation_Type value);
  inline void add_type(::ScanOperation_Type value);
  inline const ::google::protobuf::RepeatedField<int>& type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_type();
  
  // @@protoc_insertion_point(class_scope:ScanOperation)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > column_;
  ::google::protobuf::RepeatedField<int> type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_operations_2eproto();
  friend void protobuf_AssignDesc_operations_2eproto();
  friend void protobuf_ShutdownFile_operations_2eproto();
  
  void InitAsDefaultInstance();
  static ScanOperation* default_instance_;
};
// -------------------------------------------------------------------

class ComputeOperation : public ::google::protobuf::Message {
 public:
  ComputeOperation();
  virtual ~ComputeOperation();
  
  ComputeOperation(const ComputeOperation& from);
  
  inline ComputeOperation& operator=(const ComputeOperation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ComputeOperation& default_instance();
  
  void Swap(ComputeOperation* other);
  
  // implements Message ----------------------------------------------
  
  ComputeOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComputeOperation& from);
  void MergeFrom(const ComputeOperation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Operation source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Operation& source() const;
  inline ::Operation* mutable_source();
  inline ::Operation* release_source();
  
  // repeated .Expression expressions = 2;
  inline int expressions_size() const;
  inline void clear_expressions();
  static const int kExpressionsFieldNumber = 2;
  inline const ::Expression& expressions(int index) const;
  inline ::Expression* mutable_expressions(int index);
  inline ::Expression* add_expressions();
  inline const ::google::protobuf::RepeatedPtrField< ::Expression >&
      expressions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Expression >*
      mutable_expressions();
  
  // @@protoc_insertion_point(class_scope:ComputeOperation)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Operation* source_;
  ::google::protobuf::RepeatedPtrField< ::Expression > expressions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_operations_2eproto();
  friend void protobuf_AssignDesc_operations_2eproto();
  friend void protobuf_ShutdownFile_operations_2eproto();
  
  void InitAsDefaultInstance();
  static ComputeOperation* default_instance_;
};
// -------------------------------------------------------------------

class FilterOperation : public ::google::protobuf::Message {
 public:
  FilterOperation();
  virtual ~FilterOperation();
  
  FilterOperation(const FilterOperation& from);
  
  inline FilterOperation& operator=(const FilterOperation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterOperation& default_instance();
  
  void Swap(FilterOperation* other);
  
  // implements Message ----------------------------------------------
  
  FilterOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterOperation& from);
  void MergeFrom(const FilterOperation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Operation source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Operation& source() const;
  inline ::Operation* mutable_source();
  inline ::Operation* release_source();
  
  // required .Expression expression = 2;
  inline bool has_expression() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 2;
  inline const ::Expression& expression() const;
  inline ::Expression* mutable_expression();
  inline ::Expression* release_expression();
  
  // @@protoc_insertion_point(class_scope:FilterOperation)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_expression();
  inline void clear_has_expression();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Operation* source_;
  ::Expression* expression_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_operations_2eproto();
  friend void protobuf_AssignDesc_operations_2eproto();
  friend void protobuf_ShutdownFile_operations_2eproto();
  
  void InitAsDefaultInstance();
  static FilterOperation* default_instance_;
};
// -------------------------------------------------------------------

class Aggregation : public ::google::protobuf::Message {
 public:
  Aggregation();
  virtual ~Aggregation();
  
  Aggregation(const Aggregation& from);
  
  inline Aggregation& operator=(const Aggregation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Aggregation& default_instance();
  
  void Swap(Aggregation* other);
  
  // implements Message ----------------------------------------------
  
  Aggregation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Aggregation& from);
  void MergeFrom(const Aggregation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Aggregation_Type Type;
  static const Type SUM = Aggregation_Type_SUM;
  static const Type COUNT = Aggregation_Type_COUNT;
  static inline bool Type_IsValid(int value) {
    return Aggregation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Aggregation_Type_Type_MIN;
  static const Type Type_MAX =
    Aggregation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Aggregation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Aggregation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Aggregation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Aggregation_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Aggregation.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Aggregation_Type type() const;
  inline void set_type(::Aggregation_Type value);
  
  // optional int32 aggregated_column = 2;
  inline bool has_aggregated_column() const;
  inline void clear_aggregated_column();
  static const int kAggregatedColumnFieldNumber = 2;
  inline ::google::protobuf::int32 aggregated_column() const;
  inline void set_aggregated_column(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Aggregation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_aggregated_column();
  inline void clear_has_aggregated_column();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 aggregated_column_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_operations_2eproto();
  friend void protobuf_AssignDesc_operations_2eproto();
  friend void protobuf_ShutdownFile_operations_2eproto();
  
  void InitAsDefaultInstance();
  static Aggregation* default_instance_;
};
// -------------------------------------------------------------------

class GroupByOperation : public ::google::protobuf::Message {
 public:
  GroupByOperation();
  virtual ~GroupByOperation();
  
  GroupByOperation(const GroupByOperation& from);
  
  inline GroupByOperation& operator=(const GroupByOperation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupByOperation& default_instance();
  
  void Swap(GroupByOperation* other);
  
  // implements Message ----------------------------------------------
  
  GroupByOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupByOperation& from);
  void MergeFrom(const GroupByOperation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Operation source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Operation& source() const;
  inline ::Operation* mutable_source();
  inline ::Operation* release_source();
  
  // repeated int32 group_by_column = 3;
  inline int group_by_column_size() const;
  inline void clear_group_by_column();
  static const int kGroupByColumnFieldNumber = 3;
  inline ::google::protobuf::int32 group_by_column(int index) const;
  inline void set_group_by_column(int index, ::google::protobuf::int32 value);
  inline void add_group_by_column(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      group_by_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_group_by_column();
  
  // repeated .Aggregation aggregations = 4;
  inline int aggregations_size() const;
  inline void clear_aggregations();
  static const int kAggregationsFieldNumber = 4;
  inline const ::Aggregation& aggregations(int index) const;
  inline ::Aggregation* mutable_aggregations(int index);
  inline ::Aggregation* add_aggregations();
  inline const ::google::protobuf::RepeatedPtrField< ::Aggregation >&
      aggregations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Aggregation >*
      mutable_aggregations();
  
  // @@protoc_insertion_point(class_scope:GroupByOperation)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Operation* source_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > group_by_column_;
  ::google::protobuf::RepeatedPtrField< ::Aggregation > aggregations_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_operations_2eproto();
  friend void protobuf_AssignDesc_operations_2eproto();
  friend void protobuf_ShutdownFile_operations_2eproto();
  
  void InitAsDefaultInstance();
  static GroupByOperation* default_instance_;
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message {
 public:
  Operation();
  virtual ~Operation();
  
  Operation(const Operation& from);
  
  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();
  
  void Swap(Operation* other);
  
  // implements Message ----------------------------------------------
  
  Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ScanOperation scan = 1;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 1;
  inline const ::ScanOperation& scan() const;
  inline ::ScanOperation* mutable_scan();
  inline ::ScanOperation* release_scan();
  
  // optional .ComputeOperation compute = 2;
  inline bool has_compute() const;
  inline void clear_compute();
  static const int kComputeFieldNumber = 2;
  inline const ::ComputeOperation& compute() const;
  inline ::ComputeOperation* mutable_compute();
  inline ::ComputeOperation* release_compute();
  
  // optional .FilterOperation filter = 3;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 3;
  inline const ::FilterOperation& filter() const;
  inline ::FilterOperation* mutable_filter();
  inline ::FilterOperation* release_filter();
  
  // optional .GroupByOperation group_by = 4;
  inline bool has_group_by() const;
  inline void clear_group_by();
  static const int kGroupByFieldNumber = 4;
  inline const ::GroupByOperation& group_by() const;
  inline ::GroupByOperation* mutable_group_by();
  inline ::GroupByOperation* release_group_by();
  
  // @@protoc_insertion_point(class_scope:Operation)
 private:
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_compute();
  inline void clear_has_compute();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_group_by();
  inline void clear_has_group_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ScanOperation* scan_;
  ::ComputeOperation* compute_;
  ::FilterOperation* filter_;
  ::GroupByOperation* group_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_operations_2eproto();
  friend void protobuf_AssignDesc_operations_2eproto();
  friend void protobuf_ShutdownFile_operations_2eproto();
  
  void InitAsDefaultInstance();
  static Operation* default_instance_;
};
// ===================================================================


// ===================================================================

// Expression

// required .Expression.Operator operator = 1;
inline bool Expression::has_operator_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expression::set_has_operator_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expression::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expression::clear_operator_() {
  operator__ = 1;
  clear_has_operator_();
}
inline ::Expression_Operator Expression::operator_() const {
  return static_cast< ::Expression_Operator >(operator__);
}
inline void Expression::set_operator_(::Expression_Operator value) {
  GOOGLE_DCHECK(::Expression_Operator_IsValid(value));
  set_has_operator_();
  operator__ = value;
}

// repeated .Expression children = 2;
inline int Expression::children_size() const {
  return children_.size();
}
inline void Expression::clear_children() {
  children_.Clear();
}
inline const ::Expression& Expression::children(int index) const {
  return children_.Get(index);
}
inline ::Expression* Expression::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::Expression* Expression::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Expression >&
Expression::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::Expression >*
Expression::mutable_children() {
  return &children_;
}

// optional int32 constant_int32 = 10;
inline bool Expression::has_constant_int32() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expression::set_has_constant_int32() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expression::clear_has_constant_int32() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expression::clear_constant_int32() {
  constant_int32_ = 0;
  clear_has_constant_int32();
}
inline ::google::protobuf::int32 Expression::constant_int32() const {
  return constant_int32_;
}
inline void Expression::set_constant_int32(::google::protobuf::int32 value) {
  set_has_constant_int32();
  constant_int32_ = value;
}

// optional double constant_double = 11;
inline bool Expression::has_constant_double() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expression::set_has_constant_double() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expression::clear_has_constant_double() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expression::clear_constant_double() {
  constant_double_ = 0;
  clear_has_constant_double();
}
inline double Expression::constant_double() const {
  return constant_double_;
}
inline void Expression::set_constant_double(double value) {
  set_has_constant_double();
  constant_double_ = value;
}

// optional bool constant_bool = 12;
inline bool Expression::has_constant_bool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Expression::set_has_constant_bool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Expression::clear_has_constant_bool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Expression::clear_constant_bool() {
  constant_bool_ = false;
  clear_has_constant_bool();
}
inline bool Expression::constant_bool() const {
  return constant_bool_;
}
inline void Expression::set_constant_bool(bool value) {
  set_has_constant_bool();
  constant_bool_ = value;
}

// optional int32 column_id = 13;
inline bool Expression::has_column_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Expression::set_has_column_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Expression::clear_has_column_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Expression::clear_column_id() {
  column_id_ = 0;
  clear_has_column_id();
}
inline ::google::protobuf::int32 Expression::column_id() const {
  return column_id_;
}
inline void Expression::set_column_id(::google::protobuf::int32 value) {
  set_has_column_id();
  column_id_ = value;
}

// -------------------------------------------------------------------

// ScanOperation

// repeated int32 column = 1;
inline int ScanOperation::column_size() const {
  return column_.size();
}
inline void ScanOperation::clear_column() {
  column_.Clear();
}
inline ::google::protobuf::int32 ScanOperation::column(int index) const {
  return column_.Get(index);
}
inline void ScanOperation::set_column(int index, ::google::protobuf::int32 value) {
  column_.Set(index, value);
}
inline void ScanOperation::add_column(::google::protobuf::int32 value) {
  column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ScanOperation::column() const {
  return column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ScanOperation::mutable_column() {
  return &column_;
}

// repeated .ScanOperation.Type type = 2;
inline int ScanOperation::type_size() const {
  return type_.size();
}
inline void ScanOperation::clear_type() {
  type_.Clear();
}
inline ::ScanOperation_Type ScanOperation::type(int index) const {
  return static_cast< ::ScanOperation_Type >(type_.Get(index));
}
inline void ScanOperation::set_type(int index, ::ScanOperation_Type value) {
  GOOGLE_DCHECK(::ScanOperation_Type_IsValid(value));
  type_.Set(index, value);
}
inline void ScanOperation::add_type(::ScanOperation_Type value) {
  GOOGLE_DCHECK(::ScanOperation_Type_IsValid(value));
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ScanOperation::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
ScanOperation::mutable_type() {
  return &type_;
}

// -------------------------------------------------------------------

// ComputeOperation

// required .Operation source = 1;
inline bool ComputeOperation::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComputeOperation::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComputeOperation::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComputeOperation::clear_source() {
  if (source_ != NULL) source_->::Operation::Clear();
  clear_has_source();
}
inline const ::Operation& ComputeOperation::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Operation* ComputeOperation::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::Operation;
  return source_;
}
inline ::Operation* ComputeOperation::release_source() {
  clear_has_source();
  ::Operation* temp = source_;
  source_ = NULL;
  return temp;
}

// repeated .Expression expressions = 2;
inline int ComputeOperation::expressions_size() const {
  return expressions_.size();
}
inline void ComputeOperation::clear_expressions() {
  expressions_.Clear();
}
inline const ::Expression& ComputeOperation::expressions(int index) const {
  return expressions_.Get(index);
}
inline ::Expression* ComputeOperation::mutable_expressions(int index) {
  return expressions_.Mutable(index);
}
inline ::Expression* ComputeOperation::add_expressions() {
  return expressions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Expression >&
ComputeOperation::expressions() const {
  return expressions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Expression >*
ComputeOperation::mutable_expressions() {
  return &expressions_;
}

// -------------------------------------------------------------------

// FilterOperation

// required .Operation source = 1;
inline bool FilterOperation::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterOperation::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterOperation::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterOperation::clear_source() {
  if (source_ != NULL) source_->::Operation::Clear();
  clear_has_source();
}
inline const ::Operation& FilterOperation::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Operation* FilterOperation::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::Operation;
  return source_;
}
inline ::Operation* FilterOperation::release_source() {
  clear_has_source();
  ::Operation* temp = source_;
  source_ = NULL;
  return temp;
}

// required .Expression expression = 2;
inline bool FilterOperation::has_expression() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterOperation::set_has_expression() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterOperation::clear_has_expression() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterOperation::clear_expression() {
  if (expression_ != NULL) expression_->::Expression::Clear();
  clear_has_expression();
}
inline const ::Expression& FilterOperation::expression() const {
  return expression_ != NULL ? *expression_ : *default_instance_->expression_;
}
inline ::Expression* FilterOperation::mutable_expression() {
  set_has_expression();
  if (expression_ == NULL) expression_ = new ::Expression;
  return expression_;
}
inline ::Expression* FilterOperation::release_expression() {
  clear_has_expression();
  ::Expression* temp = expression_;
  expression_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Aggregation

// required .Aggregation.Type type = 1;
inline bool Aggregation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Aggregation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Aggregation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Aggregation::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Aggregation_Type Aggregation::type() const {
  return static_cast< ::Aggregation_Type >(type_);
}
inline void Aggregation::set_type(::Aggregation_Type value) {
  GOOGLE_DCHECK(::Aggregation_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 aggregated_column = 2;
inline bool Aggregation::has_aggregated_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Aggregation::set_has_aggregated_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Aggregation::clear_has_aggregated_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Aggregation::clear_aggregated_column() {
  aggregated_column_ = 0;
  clear_has_aggregated_column();
}
inline ::google::protobuf::int32 Aggregation::aggregated_column() const {
  return aggregated_column_;
}
inline void Aggregation::set_aggregated_column(::google::protobuf::int32 value) {
  set_has_aggregated_column();
  aggregated_column_ = value;
}

// -------------------------------------------------------------------

// GroupByOperation

// required .Operation source = 1;
inline bool GroupByOperation::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupByOperation::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupByOperation::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupByOperation::clear_source() {
  if (source_ != NULL) source_->::Operation::Clear();
  clear_has_source();
}
inline const ::Operation& GroupByOperation::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Operation* GroupByOperation::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::Operation;
  return source_;
}
inline ::Operation* GroupByOperation::release_source() {
  clear_has_source();
  ::Operation* temp = source_;
  source_ = NULL;
  return temp;
}

// repeated int32 group_by_column = 3;
inline int GroupByOperation::group_by_column_size() const {
  return group_by_column_.size();
}
inline void GroupByOperation::clear_group_by_column() {
  group_by_column_.Clear();
}
inline ::google::protobuf::int32 GroupByOperation::group_by_column(int index) const {
  return group_by_column_.Get(index);
}
inline void GroupByOperation::set_group_by_column(int index, ::google::protobuf::int32 value) {
  group_by_column_.Set(index, value);
}
inline void GroupByOperation::add_group_by_column(::google::protobuf::int32 value) {
  group_by_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GroupByOperation::group_by_column() const {
  return group_by_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GroupByOperation::mutable_group_by_column() {
  return &group_by_column_;
}

// repeated .Aggregation aggregations = 4;
inline int GroupByOperation::aggregations_size() const {
  return aggregations_.size();
}
inline void GroupByOperation::clear_aggregations() {
  aggregations_.Clear();
}
inline const ::Aggregation& GroupByOperation::aggregations(int index) const {
  return aggregations_.Get(index);
}
inline ::Aggregation* GroupByOperation::mutable_aggregations(int index) {
  return aggregations_.Mutable(index);
}
inline ::Aggregation* GroupByOperation::add_aggregations() {
  return aggregations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Aggregation >&
GroupByOperation::aggregations() const {
  return aggregations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Aggregation >*
GroupByOperation::mutable_aggregations() {
  return &aggregations_;
}

// -------------------------------------------------------------------

// Operation

// optional .ScanOperation scan = 1;
inline bool Operation::has_scan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation::set_has_scan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation::clear_has_scan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation::clear_scan() {
  if (scan_ != NULL) scan_->::ScanOperation::Clear();
  clear_has_scan();
}
inline const ::ScanOperation& Operation::scan() const {
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::ScanOperation* Operation::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) scan_ = new ::ScanOperation;
  return scan_;
}
inline ::ScanOperation* Operation::release_scan() {
  clear_has_scan();
  ::ScanOperation* temp = scan_;
  scan_ = NULL;
  return temp;
}

// optional .ComputeOperation compute = 2;
inline bool Operation::has_compute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operation::set_has_compute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operation::clear_has_compute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operation::clear_compute() {
  if (compute_ != NULL) compute_->::ComputeOperation::Clear();
  clear_has_compute();
}
inline const ::ComputeOperation& Operation::compute() const {
  return compute_ != NULL ? *compute_ : *default_instance_->compute_;
}
inline ::ComputeOperation* Operation::mutable_compute() {
  set_has_compute();
  if (compute_ == NULL) compute_ = new ::ComputeOperation;
  return compute_;
}
inline ::ComputeOperation* Operation::release_compute() {
  clear_has_compute();
  ::ComputeOperation* temp = compute_;
  compute_ = NULL;
  return temp;
}

// optional .FilterOperation filter = 3;
inline bool Operation::has_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operation::set_has_filter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operation::clear_has_filter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operation::clear_filter() {
  if (filter_ != NULL) filter_->::FilterOperation::Clear();
  clear_has_filter();
}
inline const ::FilterOperation& Operation::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::FilterOperation* Operation::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::FilterOperation;
  return filter_;
}
inline ::FilterOperation* Operation::release_filter() {
  clear_has_filter();
  ::FilterOperation* temp = filter_;
  filter_ = NULL;
  return temp;
}

// optional .GroupByOperation group_by = 4;
inline bool Operation::has_group_by() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operation::set_has_group_by() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operation::clear_has_group_by() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operation::clear_group_by() {
  if (group_by_ != NULL) group_by_->::GroupByOperation::Clear();
  clear_has_group_by();
}
inline const ::GroupByOperation& Operation::group_by() const {
  return group_by_ != NULL ? *group_by_ : *default_instance_->group_by_;
}
inline ::GroupByOperation* Operation::mutable_group_by() {
  set_has_group_by();
  if (group_by_ == NULL) group_by_ = new ::GroupByOperation;
  return group_by_;
}
inline ::GroupByOperation* Operation::release_group_by() {
  clear_has_group_by();
  ::GroupByOperation* temp = group_by_;
  group_by_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Expression_Operator>() {
  return ::Expression_Operator_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ScanOperation_Type>() {
  return ::ScanOperation_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Aggregation_Type>() {
  return ::Aggregation_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_operations_2eproto__INCLUDED
